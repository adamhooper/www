#!/usr/bin/env python

"""Generates winning board positions, in integer format.

Winning board positions are rows/columns/diagonals of the same color. Board.cpp
uses integer bitsets to represent boards; so we can use integer bitsets to test
for a win.

To test, in Board.cpp:
- (board.hasSet & bitset) == bitset
- (board.pieceIsWhite & bitset) == bitset -> white wins
- (board.~pieceIsWhite & bitset) == bitset -> black wins

Also available are move-finding bitsets. These are a struct with four entries:
a bitset of pieces *we* need; a bitset of pieces *they* need; a bitset of
pieces which must be empty; and a Move. This array thus contains all valid
moves.
"""

print """#ifndef WINNING_BITSETS_H
#define WINNING_BITSETS_H

/* Automatically generated by gen-winning-bitsets.py */

const long winning_bitsets[] = {"""
print "\t/* rows */"
for i in xrange(0, 5):
	print "\t0x%x," % (0x1f << (5 * i))
print "\t/* columns */"
for i in xrange(0, 5):
	print "\t0x%x," % (0x108421 << i)
print "\t/* diagonals */"
print "\t0x1041041,"
print "\t0x111110,"

print """};

const int n_winning_bitsets
	= sizeof(winning_bitsets) / sizeof(winning_bitsets[0]);
	
struct move_bitset {
	long full;
	long empty;
	long ours;
	long theirs;
	Move move;
};

const move_bitset move_bitsets[] = {"""

def toBitset(x, y): return 0x1 << (y * 5 + x)
def printMove(ours, theirs, empty, x, y, d):
	print "\t{ 0x%x, 0x%x, 0x%x, 0x%x, Move(Coord(%d, %d), Move::%s) }," % \
			(ours | theirs, empty, ours, theirs, x, y, d)

for x in xrange(0, 5):
	for y in xrange(0, 5):
		ours = toBitset(x, y)

		if (x - 2 >= 0):
			theirs = toBitset(x - 1, y)
			empty = toBitset(x - 2, y)
			printMove(ours, theirs, empty, x, y, 'DIR_W')
		if (x - 1 >= 0):
			theirs = 0
			empty = toBitset(x - 1, y)
			printMove(ours, theirs, empty, x, y, 'DIR_W')
		if (x + 1 < 5):
			theirs = 0
			empty = toBitset(x + 1, y)
			printMove(ours, theirs, empty, x, y, 'DIR_E')
		if (x + 2 < 5):
			theirs = toBitset(x + 1, y)
			empty = toBitset(x + 2, y)
			printMove(ours, theirs, empty, x, y, 'DIR_E')

		if (y - 2 >= 0):
			theirs = toBitset(x, y - 1)
			empty = toBitset(x, y - 2)
			printMove(ours, theirs, empty, x, y, 'DIR_N')
		if (y - 1 >= 0):
			theirs = 0
			empty = toBitset(x, y - 1)
			printMove(ours, theirs, empty, x, y, 'DIR_N')
		if (y + 1 < 5):
			theirs = 0
			empty = toBitset(x, y + 1)
			printMove(ours, theirs, empty, x, y, 'DIR_S')
		if (y + 2 < 5):
			theirs = toBitset(x, y + 1)
			empty = toBitset(x, y + 2)
			printMove(ours, theirs, empty, x, y, 'DIR_S')

print """};

const int n_move_bitsets
	= sizeof(move_bitsets) / sizeof(move_bitsets[0]);

struct losing_3_bitset {
	long loser;
	long winner;
};

const losing_3_bitset losing_3_bitsets[] = {
	{ (1 << 24 | 1 << 23 | 1 << 19),
	  (1 << 22 | 1 << 21 | 1 << 18 | 1 << 17
	   | 1 << 14 | 1 << 13 | 1 << 9) },
	{ (1 << 9 | 1 << 4 | 1 << 3),
	  (1 << 19 | 1 << 14 | 1 << 13 | 1 << 8
	   | 1 << 7 | 1 << 2 | 1 << 1) },
	{ (1 << 5 | 1 << 1 | 1 << 0),
	  (1 << 15 | 1 << 11 | 1 << 10 | 1 << 7
	   | 1 << 6 | 1 << 3 | 1 << 2) },
	{ (1 << 21 | 1 << 20 | 1 << 15),
	  (1 << 23 | 1 << 22 | 1 << 17 | 1 << 16
	   | 1 << 11 | 1 << 10 | 1 << 5) }
};

const int n_losing_3_bitsets
	= sizeof(losing_3_bitsets) / sizeof(losing_3_bitsets[0]);

#endif /* WINNING_BITSETS_H */"""
